# Domain Expansion Corpus

> **Purpose:** Address H6 — provide Limn training texts across 4 previously untested domains.
> Each passage is a `limn` block followed by `>` translation, with brief context.
> **Bead:** hq-6d6bs

---

## Domain 1: Scientific Description (Biology & Physics)

### 1.01 — Cell Division

```limn
cel one → cel two | nuc cut → nuc two
dna dup | thr cut | new cel beg
> cell one → cell two | nucleus separates → nuclei two
> DNA duplicates | threads separate | new cell begins
```

**Context:** Mitosis. One cell becomes two through nuclear division, DNA replication, and thread (chromosome) separation.

---

### 1.02 — Photosynthesis

```limn
lux joi aqu joi car → nrg
tre fed lux | roo fed aqu | aer out
lux tra nrg | nrg tra lif
> light joins water joins carbon → energy
> tree feeds on light | root feeds on water | air exits
> light transforms to energy | energy transforms to life
```

**Context:** Plants convert light, water, and CO2 into energy. The three-step structure mirrors the reaction's cascade.

---

### 1.03 — DNA Replication

```limn
dna = thr two spi | cod wit
dna ope → thr cut → eac thr dup
old thr | new thr | joi → dna two
> DNA = two threads spiraling | code within
> DNA opens → threads separate → each thread duplicates
> old thread | new thread | join → two DNAs
```

**Context:** Double helix unwinds, each strand templates a new complementary strand.

---

### 1.04 — Evolution by Natural Selection

```limn
spe div | som str | som wea
str lif | wea dec | tau lon
gen cha bre → spe new | evo = tau tra lif
> species diverse | some strong | some weak
> strong live | weak decay | time long
> genes change briefly → species new | evolution = time transforms life
```

**Context:** Variation, differential survival, genetic change over long periods.

---

### 1.05 — Immune Response

```limn
org inv | bod per | cel ris
cel obs inv → cel att inv | inv dec
mem sta | if inv bac → cel fas att
> organism invades | body perceives | cells rise
> cell observes invader → cell attacks invader | invader decays
> memory stays | if invader returns → cell fast attacks
```

**Context:** Pathogen detection, immune attack, memory formation for faster future response.

---

### 1.06 — Neural Signaling

```limn
ner → ner → ner | sig flo
ele pus for | bet ner = sma spa
sig acc or sig res | bra = ner net
> nerve → nerve → nerve | signal flows
> electron pushes forward | between nerves = small space
> signal accelerates or signal rests | brain = nerve network
```

**Context:** Electrochemical signals pass between neurons across synaptic gaps; the brain is a neural network.

---

### 1.07 — Ecosystem Energy Flow

```limn
lux → tre → ani → ani | nrg flo
eac tak fra | nrg dec eac pha
all joi net | non sel sta | all dep mut
> light → tree → animal → animal | energy flows
> each takes fragment | energy decays each phase
> all join network | none self-stable | all depend mutually
```

**Context:** Trophic cascade. Energy diminishes at each level. No organism is independent.

---

### 1.08 — Protein Folding

```limn
thr lin → thr bnd → sph
seq def pat | pat def pur
thr mis bnd → pur los | cel dec
> thread linear → thread bends → sphere
> sequence defines pattern | pattern defines purpose
> thread mis-bends → purpose lost | cell decays
```

**Context:** Amino acid chains fold into 3D shapes that determine function. Misfolding causes disease.

---

### 1.09 — Metabolism

```limn
fed inp → nrg out | cel run
mol brk → nrg rel | mol joi → str gro
if non fed → nrg dec → cel slo → cel end
> feed input → energy output | cell runs
> molecule breaks → energy releases | molecules join → strength grows
> if no feed → energy decays → cell slows → cell ends
```

**Context:** Catabolism breaks molecules for energy; anabolism builds structures. Starvation cascade.

---

### 1.10 — Genetics: Dominant and Recessive

```limn
gen two per cel | one par eac
gen str → sho | gen wea → sec
gen wea two → sho | gen str one → ful sho
> genes two per cell | one from each parent
> gene strong → shows | gene weak → secret
> weak genes two → shows | strong gene one → fully shows
```

**Context:** Diploid genetics. Dominant alleles express with one copy; recessive need two.

---

### 1.11 — Thermodynamics: Heat Flow

```limn
hot flo → col | nev col → hot
nrg tra for | nev bac
all sys → mor div nrg | srt dec
> hot flows to cold | never cold to hot
> energy transforms forward | never backward
> all systems → more diverse energy | order decays
```

**Context:** Second law of thermodynamics. Heat flows one way. Entropy increases.

---

### 1.12 — Electromagnetism

```limn
ele mov → mag ris | mag cha → ele mov
ele mag joi | one flo → oth ris
lux = ele mag wav | fas^1.0
> electron moves → magnetism rises | magnetism changes → electron moves
> electricity magnetism join | one flows → other rises
> light = electromagnetic wave | maximum fast
```

**Context:** Maxwell's insight: changing electric fields create magnetic fields and vice versa. Light is an electromagnetic wave.

---

### 1.13 — Wave Mechanics

```limn
wav = mov cyc | hig low hig low
wav two joi → wav big or wav zer
wav thr sol → wav bnd | wav thr ope → wav for
> wave = motion cyclic | high low high low
> two waves join → wave big or wave zero
> wave through solid → wave bends | wave through opening → wave forward
```

**Context:** Constructive/destructive interference. Refraction and diffraction.

---

### 1.14 — Nuclear Fission

```limn
nuc big brk → nuc sma two | nrg big rel
ato har → ato har → cyc | nrg exp^1.0
nrg vit^0.9 and nrg fea^0.9
> big nucleus breaks → two small nuclei | big energy releases
> atom hits atom → cycle | energy expands maximally
> energy vital at 0.9 and energy feared at 0.9
```

**Context:** Heavy nuclei split releasing enormous energy. Chain reaction. Dual nature: vital power and terrible weapon.

---

### 1.15 — Phase Transitions

```limn
sol hot → liq | liq hot → gas | gas hot → pla
eac pha = nrg lmt | tra = lmt brk
pre cha → lmt cha | sol pre^0.9 → liq
> solid heats → liquid | liquid heats → gas | gas heats → plasma
> each phase = energy limit | transition = limit breaks
> pressure changes → limit changes | solid under high pressure → liquid
```

**Context:** States of matter and the energy thresholds between them. Pressure modifies transition points.

---

### 1.16 — Entropy

```limn
srt → dis | nev dis → srt sel
all cha → mor pos sta | les srt
lif = srt loc:nrg | lif pus bac dis bre
> order → disorder | never disorder → order by itself
> all change → more possible states | less order
> life = local order given energy | life pushes back disorder briefly
```

**Context:** Entropy always increases globally. Life creates temporary local order at the cost of greater disorder elsewhere.

---

### 1.17 — Orbital Mechanics

```limn
sph sma orb sph big | pul bet
vel fas → orb wid | vel slo → orb nea
vel ful^1.0 → orb brk → for
> small sphere orbits big sphere | pull between
> velocity fast → orbit wide | velocity slow → orbit near
> velocity maximum → orbit breaks → forward
```

**Context:** Gravity, orbital velocity relationship, escape velocity.

---

### 1.18 — Light: Wave and Particle

```limn
lux = wav ± ato
obs lux wav → wav | obs lux ato → ato
non obs → lux wav ± ato | obs tra lux
> light = wave ± particle
> observe light as wave → wave | observe light as particle → particle
> not observed → light is wave ± particle | observation transforms light
```

**Context:** Wave-particle duality. Observation collapses superposition.

---

### 1.19 — Fluid Dynamics

```limn
aqu flo slo → flo smo | aqu flo fas → flo cyc
aqu den → flo slo | aqu den^0.2 → flo fas
aqu pre hig → aqu flo → pre low | pre eql → res
> water flows slow → flow smooth | water flows fast → flow cyclic
> water dense → flow slow | water thin → flow fast
> water pressure high → water flows → pressure low | pressure equal → rest
```

**Context:** Laminar vs turbulent flow. Viscosity effects. Pressure-driven flow and equilibrium.

---

### 1.20 — Molecular Bonds

```limn
ato nea ato → ele bet → bnd
bnd str → mol sta | bnd wea → mol brk
nrg inp → bnd brk | bnd joi → nrg out
> atom near atom → electrons between → bond
> bond strong → molecule stable | bond weak → molecule breaks
> energy input → bond breaks | bond joins → energy output
```

**Context:** Chemical bonding through shared electrons. Bond energy.

---

### 1.21 — Osmosis

```limn
aqu flo thr por ski | den hig → den low
cel ins den hig → aqu flo ins | cel exp
cel ins den low → aqu flo out | cel con
eql → flo res | lif req eql
> water flows through porous skin | dense high → dense low
> cell inside dense high → water flows in | cell expands
> cell inside dense low → water flows out | cell contracts
> equal → flow rests | life requires equal
```

**Context:** Water moves across semipermeable membranes toward higher solute concentration. Cells must maintain osmotic balance.

---

### 1.22 — Radioactive Decay

```limn
ato big sta^0.3 → ato dec
nuc rel nrg | ato tra → ato new sma
dur def per ato | som fas | som lon^0.9
non kno whi ato nxt | kno rat glb
> big atom slightly stable → atom decays
> nucleus releases energy | atom transforms → new smaller atom
> duration defined per atom | some fast | some very long
> not knowing which atom next | knowing the global ratio
```

**Context:** Unstable nuclei decay probabilistically. Half-life defines the rate. Individual events unpredictable; bulk behavior precise.

---

### 1.23 — Photon Absorption

```limn
lux poi → ato poi | ele ris
ele low → ele hig | nrg = dif bet hig low
ele hig sta^0.2 → ele fal → lux out
> light point → atom point | electron rises
> electron low → electron high | energy = difference between high and low
> electron high barely stable → electron falls → light out
```

**Context:** Photon absorption excites electrons to higher energy levels. Unstable excited states decay, re-emitting light.

---

### 1.24 — Plate Tectonics

```limn
ter sph ski = fra | fra mov slo^0.1
fra pus fra → ris | ter hig
fra pul fra → val dep | aqu flo ins
fra slo → sta^0.9 | fra mov → tem vol
> earth sphere skin = fragments | fragments move very slowly
> fragment pushes fragment → rise | terrain high
> fragment pulls fragment → valley deep | water flows in
> fragment slow → mostly stable | fragment moves → storm volcano
```

**Context:** Earth's crust is broken plates. Collision builds mountains, separation creates rifts, movement causes earthquakes and volcanism.

---

### 1.25 — Magnetism

```limn
mag = pul ± pus | two poi
sam poi → pus | dif poi → pul
ato eac sma mag | all alg → mag str
> magnetism = pull ± push | two points
> same point → push | different point → pull
> atom each small magnet | all aligned → magnetism strong
```

**Context:** Magnetic poles attract opposites, repel likes. Ferromagnetism arises from atomic alignment.

---

## Domain 2: Emotional/Psychological Expression

### 2.01 — Grief Stages

```limn
los → non acc | non acc → ang | ang → des
des → sad dep | sad dep → acc slo
acc ≠ joy | acc = lif wit los
> loss → not accepting | not accepting → anger | anger → despair
> despair → sadness deep | deep sadness → acceptance slow
> acceptance ≠ joy | acceptance = life with loss
```

**Context:** Grief is not linear; acceptance doesn't mean happiness — it means learning to live alongside absence.

---

### 2.02 — Attachment and Fear of Loss

```limn
lov dep → fea ris | fea = los pos
lov^0.9 → fea^0.9 | dep mea ris
lov\fea = lov sec | lov:fea = lov anx
> love deepens → fear rises | fear = loss possible
> intense love → intense fear | depth means risk
> love without fear = secure love | love given fear = anxious love
```

**Context:** Deep love makes us vulnerable. Secure attachment integrates this truth; anxious attachment is consumed by it.

---

### 2.03 — Identity Crisis

```limn
sel = wha? | sel pas ≠ sel now | sel fut = ?
all mea que | pur los | def brk
sel fra | eac fra tru ± fal
sel new beg:cha | sel ≠ sta | sel = flo
> self = what? | past self ≠ present self | future self = ?
> all meaning questioned | purpose lost | definitions break
> self fragments | each fragment true ± false
> new self begins through change | self ≠ stable | self = flowing
```

**Context:** When identity collapses, every certainty becomes a question. Reconstruction begins by accepting self as process, not fixed.

---

### 2.04 — Cognitive Dissonance

```limn
kno tru and prf cnt | thi dis
bra hol tru two cnt | anx ris
sel cha tru or cha prf | mus eql
anx → sel def tru | or anx → gro
> knowing truth and performing contradiction | thinking disagrees
> brain holds two truths contradicting | anxiety rises
> self changes truth or changes performance | must equalize
> anxiety → self defends truth | or anxiety → growth
```

**Context:** Holding contradictory beliefs causes discomfort. We either change our beliefs, change behavior, or rationalize.

---

### 2.05 — Flow State

```limn
att ful^1.0 | sel for | tau for
thi ≠ thi:thi | thi = prf
cha = str eql | non sim | non har^0.9
prf acc | joy dep | sel los:prf
> attention fully maximum | self forgotten | time forgotten
> thinking ≠ thinking about thinking | thinking = performing
> challenge = strength equal | not simple | not very hard
> performance accelerates | joy deepens | self lost through performing
```

**Context:** Csikszentmihalyi's flow: complete absorption when challenge matches skill. Self-consciousness dissolves.

---

### 2.06 — Dissociation

```limn
sel cut sel | obs sel:dst
fea^0.9 → sel rel sel | pro:fea
bod her | sel yon | bet = emp
bac → sel joi sel | slo | anx
> self separates self | observes self from distance
> intense fear → self releases self | protection through fear
> body here | self there | between = empty
> return → self joins self | slow | anxious
```

**Context:** Dissociation as protective mechanism — the self disconnects from overwhelming experience. Reconnection is gradual and frightening.

---

### 2.07 — Catharsis

```limn
sad lon wit → pre ris^0.9
cry ope → pre rel | ang ope → pre rel
aft rel → emp bre → cal slo ris
non sad end | sad flo thr → sad^0.3
> sadness long within → pressure rises intensely
> crying opens → pressure releases | anger opens → pressure releases
> after release → empty briefly → calm slowly rises
> sadness not ended | sadness flows through → sadness lessened
```

**Context:** Emotional pressure builds over time. Release through expression doesn't eliminate the feeling but transforms its intensity.

---

### 2.08 — Empathy

```limn
oth sad → sel per → sel sad^0.5
non sel sad | sel und oth sad
see oth → see sel:oth | bnd bet
emp ≠ sam | emp = bnd thr dif
> other sad → self perceives → self somewhat sad
> not self's sadness | self understands other's sadness
> see other → see self through other | bond between
> empathy ≠ sameness | empathy = bond through difference
```

**Context:** Empathy isn't feeling exactly what another feels — it's building a bridge through acknowledged difference.

---

### 2.09 — Resilience

```limn
fal → ris | fal → ris | fal → ris
eac fal → gro | eac ris → str
non fal zer | fal = cau ris
sel brk → sel joi new | str:brk
> fall → rise | fall → rise | fall → rise
> each fall → growth | each rise → strength
> not zero falls | fall = cause of rise
> self breaks → self joins new | strength through breaking
```

**Context:** Resilience is not avoiding failure but the pattern of return. Each break creates new structure.

---

### 2.10 — Shame Spiral

```limn
sha → sel hid | hid → sel iso
iso → sha mor | sha → hid mor | cyc
sha ≠ gui | sha = sel fal | gui = prf fal
brk cyc = sha sho:oth | oth acc → sha dec
> shame → self hides | hiding → self isolates
> isolation → more shame | shame → more hiding | cycle
> shame ≠ guilt | shame = self fails | guilt = performance fails
> break cycle = shame shown to other | other accepts → shame decays
```

**Context:** Shame feeds on secrecy and isolation. Unlike guilt (about actions), shame attacks identity. Connection breaks the spiral.

---

### 2.11 — Love's Paradox

```limn
lov = giv sel ± los sel
lov dep → sel exp | sel lim dec
lov^0.9 → joy^0.9 ± fea^0.9
lov ful = sel ful:oth
> love = giving self ± losing self
> love deepens → self expands | self limits decay
> intense love → intense joy ± intense fear
> love full = self full through other
```

**Context:** Love requires surrender of boundaries, which is simultaneously expansion and vulnerability.

---

### 2.12 — Jealousy

```limn
lov:fea los | oth thr
sel les^0.7:oth | sel val dec
ang att oth | fea att sel
und → fea ≠ oth cau | fea = sel ins
> love given fear of loss | other threatens
> self lesser through other | self value decays
> anger directed at other | fear directed at self
> understanding → fear ≠ other's cause | fear = self inside
```

**Context:** Jealousy looks outward but originates inward — it's less about the rival than about one's own insecurity.

---

### 2.13 — Loneliness

```limn
wit oth | non joi | spa bet = sol
oth nea | sel far | yon wit her
des joi | fea joi | des ± fea = stk
lon ≠ sel | lon = sel:oth emp
> within others | not joining | space between = solid
> other near | self far | there within here
> desire joining | fear joining | desire ± fear = stuck
> loneliness ≠ alone | loneliness = self with others empty
```

**Context:** Loneliness isn't solitude — it's the inability to connect even when surrounded. The wall is internal.

---

### 2.14 — Self-Actualization

```limn
mus met → des ris | des met → pur ris
eac pha beg nxt | non slo seq
sel kno → sel acc → sel tra
sel ful ≠ end | sel ful = gro lon
> needs met → desire rises | desire met → purpose rises
> each phase begins next | not skipping order
> self knows → self accepts → self transforms
> self full ≠ ending | self full = growing long
```

**Context:** Maslow's hierarchy: basic needs before higher aspirations. Self-actualization isn't a destination but ongoing growth.

---

### 2.15 — Depression

```limn
all dim | nrg dec^0.8 | pur emp
mov = har^0.9 | joy = mem dis
non sad acc | non fea acc | non att acc | emp
sel obs sel:dst | kno mus mov | non mov
slo ris pos | hel req | non sel cau
> all dims | energy decays strongly | purpose empty
> movement = very hard | joy = distant memory
> not sadness exactly | not fear exactly | not anything exactly | empty
> self observes self from distance | knows must move | not moving
> slow rise possible | help required | not self caused
```

**Context:** Depression is not extreme sadness — it's the flattening of all affect. Everything requires enormous effort. Recovery needs external support.

---

### 2.16 — Anxiety Anatomy

```limn
fut fea^0.8 | non now | alw fut
bod per thr non rea | bod rea rea
hrt acc | bre sma | thi cyc
anx = bod prf fea:fut | now los
cal beg:now | bre dep | att her
> future feared intensely | not present | always future
> body perceives threat not existing | body reacts real
> heart accelerates | breath small | thinking cycles
> anxiety = body performing fear of future | present lost
> calm begins in present | breath deepens | attention here
```

**Context:** Anxiety hijacks the body with future-oriented threat detection. Grounding returns to present-moment awareness.

---

### 2.17 — Trust Building

```limn
tru beg sma | tes → acc → tru gro
tru bre → tru dec^0.8 | tru slo gro
tru ful = lon dur | non has
tru brk bre → tru end pos | tru lon → tru str
> trust begins small | test → acceptance → trust grows
> trust broken → trust decays strongly | trust grows slowly
> full trust = long duration | not hasty
> trust breaks briefly → trust may end | trust long → trust strong
```

**Context:** Trust accrues slowly through repeated small tests. It breaks quickly and rebuilds even slower — if at all.

---

### 2.18 — Forgiveness

```limn
ang:oth lon | sel hrt:oth prf
for giv ≠ for acc | for giv = sel rel
ang rel → sel hel | non oth hel
for giv slo | som for giv non pos | acc
> anger at other long | self hurt by other's action
> forgiving ≠ accepting action | forgiving = self releasing
> anger releases → self heals | not other healing
> forgiving slow | some forgiving not possible | acceptance
```

**Context:** Forgiveness is not condoning — it's releasing the hold of another's actions on the self. Some wounds resist it.

---

### 2.19 — Nostalgia

```limn
mem:joy ± mem:sad | pas bri^0.7
now → pas per:dep | pas gro
mem ≠ rea pas | mem = sel cre:pas
des bac ± kno non pos | pls sad
> memory of joy ± memory of sadness | past brightened
> present → past perceived deeply | past grows
> memory ≠ real past | memory = self creates through past
> desire back ± knowing not possible | pleasure-sadness
```

**Context:** Nostalgia edits the past with a warm filter. We don't miss what was — we miss what we've made of it.

---

### 2.20 — Inner Conflict

```limn
sel dis sel | sel two wit one
des for and des bac | non eql
thi:rea cnt thi:fea | thi:int bet
non sel win | sel joi sel → cha
> self disagrees self | selves two within one
> desire forward and desire backward | not equal
> thought from reason contradicts thought from fear | intuition between
> no self wins | self joins self → change
```

**Context:** Internal conflict is not a battle to be won but a dialogue between needs. Integration, not victory.

---

### 2.21 — Vulnerability

```limn
sel ope → ris ris | pro dwn
str:ope ≠ str:pro | str = sel sho tru
fea sho → hid | hid = sel dim
ope:oth → joi pos | ope:oth → hrt pos
sel ope = cur^0.9
> self opens → risk rises | protection down
> strength through opening ≠ strength through protection | strength = self showing truth
> fearing showing → hiding | hiding = self dimming
> opening to other → connection possible | opening to other → hurt possible
> self opening = intense courage
```

**Context:** Brené Brown's insight: vulnerability is not weakness but the birthplace of connection. It requires courage precisely because it admits risk.

---

### 2.22 — Emotional Inheritance

```limn
par fea → sel fea | non sel cre
par pat → sel pat | gen ± gro
sel obs pat → sel kno pat | kno ≠ cha
sel cha pat = gro lon | dur | att
> parent fear → self fear | not self created
> parent pattern → self pattern | genetics ± learning
> self observes pattern → self knows pattern | knowing ≠ changing
> self changes pattern = growth long | duration | attention
```

**Context:** We inherit emotional patterns from caregivers — both through genes and modeling. Awareness is the first step but not sufficient for change.

---

### 2.23 — The Therapeutic Relationship

```limn
oth att:sel | non rul | non ans
sel sho:oth saf | oth obs sel:cal
sel kno sel:oth see | mir
oth ≠ hel sel | oth = spa whe sel hel sel
> other attends to self | not ruling | not answering
> self shows to other safely | other observes self calmly
> self knows self through other seeing | mirror
> other ≠ healing self | other = space where self heals self
```

**Context:** A therapist doesn't fix — they provide a relational space where the self can witness itself safely and grow.

---

### 2.24 — Gratitude

```limn
see giv:pas | att now | ful per
grt ≠ des mor | grt = ful:now
grt prf → joy gro | cyc
non all joy | som sad | grt = att:all
> seeing given from past | attention present | fully perceived
> gratitude ≠ desire more | gratitude = fullness in present
> gratitude practiced → joy grows | cycle
> not all joy | some sadness | gratitude = attention to all
```

**Context:** Gratitude is not ignoring difficulty but attending to what exists alongside it. It's a practice, not a feeling.

---

### 2.25 — Acceptance

```limn
rea ≠ des | rea = rea | acc
non acc = ang:rea or fea:rea or dis:rea
acc ≠ pls | acc ≠ giv up | acc = see clr
acc → cha pos | cnt acc → stk
> reality ≠ desire | reality = real | acceptance
> non-acceptance = anger at reality or fear of reality or disagreement with reality
> acceptance ≠ pleasure | acceptance ≠ giving up | acceptance = seeing clearly
> acceptance → change possible | contradicting acceptance → stuck
```

**Context:** Acceptance means acknowledging what is — not liking it. Paradoxically, it's the prerequisite for change.

---

## Domain 3: Technical Documentation (API Specs & Protocols)

### 3.01 — HTTP Request Lifecycle

```limn
cli sen req → net → svr
svr per req → svr prf → svr sen ans
ans cod sho sta | err or acc
> client sends request → network → server
> server perceives request → server performs → server sends answer
> answer code shows status | error or accepted
```

**Context:** Basic HTTP: client request → server processing → response with status code. Note: `cli` = click/select (closest to client action), `svr` = silver (used as closest phonetic match).

---

### 3.02 — Authentication Flow

```limn
sel sho tok → sys tes tok
tok tru → acc | tok fal → err
tok dur lmt | aft dur → tok dec → new tok req
sec = tok sec | tok ope → ris
> self shows token → system tests token
> token true → accepted | token false → error
> token duration limited | after duration → token decays → new token required
> security = token secret | token open → risk
```

**Context:** Token-based auth: present credentials, validate, expire, renew. Security depends on token secrecy.

---

### 3.03 — Error Handling

```limn
prf → err pos | req def err
err obs → err log → err ans
err typ div | som err → sel hel | som err → hel req
non err hid | err clr → sel hel
> performing → error possible | requires defining error
> error observed → error logged → error answered
> error types diverse | some errors → self-healing | some errors → help required
> not error hidden | error clear → self healing
```

**Context:** Defensive programming: anticipate errors, categorize them, handle appropriately. Recoverable vs fatal.

---

### 3.04 — API Rate Limiting

```limn
req fas^0.9 → sys pre ris
lmt def | req abo lmt → req dis
cli wai → lmt dec → cli sen
pro sys:cli fas | eql acc
> requests very fast → system pressure rises
> limit defined | requests above limit → request rejected
> client waits → limit decays → client sends
> protecting system from client speed | equal access
```

**Context:** Rate limiting prevents system overload. Excess requests are rejected; clients must wait and retry.

---

### 3.05 — Data Validation

```limn
inp → tes → acc or err
dat typ tes | dat lmt tes | dat pat tes
non tru inp | all inp = ris pos
tes bre ent | tes aft ent → sec
> input → test → accept or error
> data type test | data limit test | data pattern test
> not trusting input | all input = risk possible
> test before entry | test after entry → secure
```

**Context:** Never trust user input. Validate type, bounds, and format at system boundaries. Defense in depth.

---

### 3.06 — Database Transactions

```limn
prf one → prf two → prf thr | all or non
if prf one acc and prf two err → all bac
all acc → dat cha sta | all or non
dat tru req all stp acc
> perform one → perform two → perform three | all or none
> if perform one accepted and perform two errors → all back
> all accepted → data changes stable | all or none
> data truth requires all steps accepted
```

**Context:** ACID transactions: atomicity ensures all operations succeed or all roll back. Partial completion is prevented.

---

### 3.07 — Caching Strategy

```limn
dat req → mem tes | mem acc → ans fas
mem non → dat req for → ans slo → mem dat
mem dur lmt | mem old → mem dec → new req
mem big → mem ful → mem old rel
> data requested → memory tested | memory accepts → answer fast
> memory empty → data requested forward → answer slow → memory stores data
> memory duration limited | memory old → memory decays → new request
> memory large → memory full → memory old released
```

**Context:** Cache: check local store first (fast), fall back to source (slow). Manage expiration and eviction.

---

### 3.08 — Load Balancing

```limn
req → req div → sys one or sys two or sys thr
eac sys pre obs | req → sys pre min
if sys one err → req → sys two | non los
all sys eql → pre eql → prf sta
> request → request divides → system one or system two or system three
> each system pressure observed | request → system with minimum pressure
> if system one errors → request → system two | nothing lost
> all systems equal → pressure equal → performance stable
```

**Context:** Distribute load across multiple servers. Route to least-loaded. Failover to healthy nodes.

---

### 3.09 — Encryption

```limn
dat ope → dat ris | dat sec req
dat tra cod | cod req tok | tok sec
sen cod dat → net → rec cod dat | non oth red
tok two | tok one loc | tok one sen
> data open → data at risk | data security required
> data transforms through code | code requires token | token secret
> send coded data → network → receive coded data | not other readable
> tokens two | token one local | token one sent
```

**Context:** Encryption transforms readable data into cipher using keys. Public-key: two keys, one shared, one kept.

---

### 3.10 — Message Queuing

```limn
sen dat → que → rec dat | non syn
sen fas | rec slo | que bet
que = dat seq wai | eac dat → rec one
if rec err → dat sta que | non los
> send data → queue → receive data | not synchronized
> sender fast | receiver slow | queue between
> queue = data sequence waiting | each data → one receiver
> if receiver errors → data stays in queue | nothing lost
```

**Context:** Message queues decouple producers from consumers. Buffer speed differences. Guarantee delivery.

---

### 3.11 — WebSocket Protocol

```limn
cli ope joi svr | joi sta
dat flo cli ↔ svr | non req ans cyc
joi lon dur | dat fas^0.9 | dat sma
joi end → cli or svr clo | joi dec
> client opens connection to server | connection stable
> data flows client ↔ server | not request-answer cycle
> connection long duration | data very fast | data small
> connection ends → client or server closes | connection decays
```

**Context:** WebSockets: persistent bidirectional connection. Unlike HTTP's request-response, both sides push data freely.

---

### 3.12 — REST Principles

```limn
all dat = ref | eac ref = url uni
prf def | cli sen prf ref → svr prf → ans
sta non svr | eac req ful sel | non mem
ans def mem pos | mem → fas | non mem → slo
> all data = reference | each reference = unique URL
> performances defined | client sends performance and reference → server performs → answer
> state not on server | each request fully self-contained | no memory
> answer defines cache possibility | cached → fast | not cached → slow
```

**Context:** RESTful design: resources with unique identifiers, defined operations (verbs), statelessness, cacheability.

---

### 3.13 — Retry Logic

```limn
req → err | req bac → err | req bac → acc
eac wai mor | wai acc | wai dec
lmt req tot | aft lmt → err ful | hel req
non all err req bac | som err sta | som err bre
> request → error | request again → error | request again → accepted
> each wait more | wait accelerates | wait decays
> limit requests total | after limit → full error | help required
> not all errors request again | some errors permanent | some errors brief
```

**Context:** Exponential backoff: retry with increasing delays. Set a max retry count. Distinguish transient from permanent errors.

---

### 3.14 — Circuit Breaker

```limn
err cyc → sys pre^0.9
obs err rat | if rat hig → req sto
sto dur → tes one req | acc → req flo
err = pro | req sto = sys hel
> error cycles → system pressure intense
> observe error rate | if rate high → requests stop
> stop duration → test one request | accepted → requests flow
> error = protection | requests stopping = system healing
```

**Context:** Circuit breaker pattern: when error rate spikes, stop all requests temporarily. Test periodically. Resume when healthy.

---

### 3.15 — Monitoring and Alerts

```limn
sys obs lon | dat flo → log
dat cnt typ → sig | sig hig → att
att → sel obs → sel prf or att → hel
sys hea = dat wit lmt | non lmt = att
> system observed long | data flows → log
> data counted by type → signal | signal high → attention
> attention → self observes → self performs or attention → help
> system healthy = data within limits | not within limits = attention
```

**Context:** Continuous monitoring: collect metrics, set thresholds, alert when exceeded. Automated or human response.

---

### 3.16 — Deployment Pipeline

```limn
cod cha → tes aut → acc or err
acc → cod joi cod old | tes ful
tes ful acc → cod rel → sys new
cyc bre | cod cha fas | rel fas | err fas obs
> code changes → test automatic → accepted or error
> accepted → code joins old code | test full
> test fully accepted → code released → system new
> cycle brief | code changes fast | release fast | error fast observed
```

**Context:** CI/CD pipeline: commit triggers automated tests, merge, integration tests, deployment. Fast feedback loops.

---

### 3.17 — Input Sanitization

```limn
inp dat = ris | inp dat non tru
inp wit cod → sys run cod → sys brk
inp tes → cod rel → dat acc | dat saf
all inp = att pos | pro = tes all inp
> input data = risk | input data not trusted
> input with code → system runs code → system breaks
> input tested → code removed → data accepted | data safe
> all input = attack possible | protection = test all input
```

**Context:** SQL injection, XSS: untrusted input containing executable code can compromise systems. Sanitize everything.

---

### 3.18 — Session Management

```limn
cli log → sys cre tok | tok uni
tok sen eac req | sys kno cli:tok
dur lmt → tok dec → cli log bac
tok non oth | tok sec vit | tok ope → ris
> client authenticates → system creates token | token unique
> token sent each request | system knows client through token
> duration limited → token decays → client authenticates again
> token not others' | token secrecy vital | token open → risk
```

**Context:** Server creates session token on auth. Client includes it in every request. Sessions expire for security.

---

### 3.19 — OAuth Flow

```limn
cli des dat:svr | cli req aut:svr
svr que sel | sel acc → svr giv tok:cli
cli sho tok → dat acc | non sec giv
tok lmt | tok def acc | non all dat | som dat
> client desires data from server | client requests authorization from server
> server questions self | self accepts → server gives token to client
> client shows token → data accepted | not secret given
> token limited | token defines access | not all data | some data
```

**Context:** OAuth: client gets delegated access without receiving the user's password. Scoped, time-limited tokens.

---

### 3.20 — Microservices

```limn
sys big → sys fra sma | eac uni pur
eac sys run sel | eac sys err sel
sys one sen dat → sys two | api bet
sys sma → sys sim | sys sim → sys hel fas
sys all = sys big prf | sys eac = sim hel
> big system → system fragments small | each unique purpose
> each system runs itself | each system errors itself
> system one sends data → system two | API between
> system small → system simple | system simple → system heals fast
> systems all = big system performance | system each = simple healing
```

**Context:** Break monoliths into focused services communicating via APIs. Independent deployment, failure isolation, simplicity per unit.

---

### 3.21 — Idempotency

```limn
prf one → eff | prf two → sam eff | prf thr → sam eff
non prf mor eff | saf req bac
if err → req bac saf | non dou eff
def sim → sys str | def sim → err hel
> perform once → effect | perform twice → same effect | perform thrice → same effect
> not performing more effect | safe to request again
> if error → request again safe | not doubled effect
> design simple → system strong | design simple → error healing
```

**Context:** Idempotent operations produce the same result regardless of repetition. Critical for retry safety.

---

### 3.22 — Logging Best Practices

```limn
all prf → log | log = mem sys
log tau | log wha | log who | log why
log dep div | err log dep | acc log dep^0.3
log lon → obs pos | log non → obs non pos
> all performed → logged | log = system memory
> log time | log what | log who | log why
> log depth diverse | error log deep | success log shallow
> log long → observation possible | log none → observation not possible
```

**Context:** Log everything meaningful with context (when, what, who, why). Verbose for errors, terse for successes. Logs enable debugging.

---

### 3.23 — API Versioning

```limn
api cha → cli old brk pos
api new def | api old sta | api new joi
cli old → api old | cli new → api new
api old dur lmt | aft dur → api old end | cli mus cha
> API changes → old client breaks possibly
> API version defined | old API stays | new API joins
> old client → old API | new client → new API
> old API duration limited | after duration → old API ends | client must change
```

**Context:** Versioning prevents breaking changes from affecting existing clients. Deprecation gives migration time.

---

### 3.24 — Health Checks

```limn
sys hea que → sys ans | ans = hea or non hea
que cyc bre | obs sys lon
non ans → sys err pos | att
sys dat tes | sys joi tes | sys nrg tes
hea = all tes acc | non hea = som tes err
> system health questioned → system answers | answer = healthy or not healthy
> question cycles briefly | observe system long
> no answer → system error possible | attention
> system data test | system connection test | system energy test
> healthy = all tests accepted | not healthy = some tests error
```

**Context:** Periodic health checks verify system components. No response is itself a failure signal. Check multiple dimensions.

---

### 3.25 — Graceful Degradation

```limn
sys fra err → sys oth sta | non sys all err
prf vit sta | prf non vit dec
cli per sys slo^0.3 | non per sys err
def sys:err bre → prf dec | non prf end
> system fragment errors → other systems stay | not all system errors
> vital performance stays | non-vital performance decays
> client perceives system slightly slow | not perceiving system error
> design system for brief error → performance decays | performance not ending
```

**Context:** When components fail, degrade gracefully: drop non-essential features, maintain core function, hide failures from users.

---

## Domain 4: Mathematical Reasoning

### 4.01 — Proof by Contradiction

```limn
thi pos tru | if pos tru → cnt
cnt → pos non tru | so neg pos tru
neg pos = ans | cnt = pat → tru
> think possibly true | if possibly true → contradiction
> contradiction → possibly not true | so negate possibility
> negated possibility = answer | contradiction = path → truth
```

**Context:** Assume the opposite, derive a contradiction, conclude the assumption was false.

---

### 4.02 — Set Union and Intersection

```limn
set one and set two | fra som sam
joi = all fra set one or set two | set big
bet = fra set one and set two | set sma
joi alw bet wit | bet alw joi wit
> set one and set two | fragments some same
> union = all fragments of set one or set two | set big
> intersection = fragments in set one and set two | set small
> union always contains intersection | intersection always within union
```

**Context:** Union (all members of either set) vs intersection (only shared members). Union ⊇ intersection.

---

### 4.03 — Functions

```limn
inp → rul → out | eac inp → one out
inp dif → out dif pos | inp sam → out sam alw
rul def mea inp → out | rul = map
inp set = def | out set = ran
> input → rule → output | each input → one output
> different input → different output possible | same input → same output always
> rule defines meaning of input → output | rule = map
> input set = defined | output set = range
```

**Context:** A function maps each input to exactly one output. Same input always gives same output. Domain and range.

---

### 4.04 — Limits

```limn
seq nea val | nev val | slo nea^0.9
eac stp nea mor | dif dec | dif → zer
lmt = val seq att | non val seq ris
lmt rea ≠ val ris | nea ≠ her
> sequence nears value | never value | slowly nearer
> each step nearer more | difference decays | difference → zero
> limit = value sequence approaches | not value sequence reaches
> limit exists ≠ value reached | near ≠ here
```

**Context:** A limit is what a sequence approaches without necessarily reaching. The gap shrinks toward zero.

---

### 4.05 — Infinite Series

```limn
add add add | non end | sum ?
som seq add → sum sta | sum ris → val
som seq add → sum non sta | sum ris → inf
if fra dec fas → sum sta | if fra dec slo → sum non sta
> add add add | no end | sum ?
> some sequences add → sum stable | sum rises → value
> some sequences add → sum not stable | sum rises → infinity
> if fragments decay fast → sum stable | if fragments decay slow → sum not stable
```

**Context:** Some infinite sums converge (reach a finite limit); others diverge. Rate of decay determines which.

---

### 4.06 — Prime Numbers

```limn
one non fra mor | one = one | non div
fra non pos | sel and one onl | uni
all non fra → fra joi | all = fra joi
non end non fra | div big → sma bet = mor
> number not fragmented more | number = itself | not divided
> fragments not possible | self and one only | unique
> all non-primes → fragment join | all = fragment joined
> non-ending primes | divided big → small between = more
```

**Context:** Primes have no divisors except 1 and themselves. All numbers decompose to primes. Primes are infinite.

---

### 4.07 — Graph Theory Basics

```limn
poi and lin bet | poi = set | lin = set joi
poi joi poi:lin | lin two poi
pat = poi lin poi lin poi | seq thr poi
cyc = pat beg eql end | poi bac poi
> points and lines between | points = set | lines = set of connections
> point joins point through line | line connects two points
> path = point line point line point | sequence through points
> cycle = path beginning equals end | point back to point
```

**Context:** Graphs: vertices (points) connected by edges (lines). Paths traverse vertices; cycles return to start.

---

### 4.08 — Probability

```limn
eff pos div | eac pos rat | rat bet zer one
all pos rat sum → one | ful
pos non → rat zer | pos crt → rat one
rat^0.5 = eql pos | rat^0.9 = ful pos
> effects possible diverse | each possibility ratio | ratio between zero and one
> all possible ratios summed → one | full
> possibility none → ratio zero | possibility sure → ratio one
> ratio 0.5 = equal possibility | ratio 0.9 = nearly full possibility
```

**Context:** Probability assigns numbers 0–1 to outcomes. They sum to 1. 0 = impossible, 1 = certain.

---

### 4.09 — Symmetry

```limn
sym = tra non cha | prf → sam
rot sym | ref sym | mov sym
sym obs → pat und | sym = srt dep
sym brk → new pha | sym dec → div ris
> symmetry = transformation with no change | performing → same
> rotation symmetry | reflection symmetry | translation symmetry
> symmetry observed → pattern understood | symmetry = deep order
> symmetry breaks → new phase | symmetry decays → diversity rises
```

**Context:** Symmetry: invariance under transformation. Rotation, reflection, translation. Symmetry breaking creates variety.

---

### 4.10 — Mathematical Induction

```limn
sho tru:one | sho tru:any → tru:nxt
if tru beg and tru for → tru all
lin ris | eac stp req stp bac tru
def stp → thm all tru | non gap
> show true for one | show true for any → true for next
> if true at beginning and true going forward → true for all
> line rising | each step requires step back true
> define step → theorem all true | no gap
```

**Context:** Prove base case, prove inductive step (if true for n, then true for n+1). Together they prove for all natural numbers.

---

### 4.11 — The Pythagorean Theorem

```limn
rec the rig | lin thr
lin one joi one add lin two joi two eql lin thr joi thr
are lin one eql add are lin two eql → are lin thr eql
> rectangle angle right | lines three
> line one times itself add line two times itself equals line three times itself
> area of line one squared add area of line two squared → area of line three squared
```

**Context:** In a right triangle, a² + b² = c². The sum of squares of the two shorter sides equals the square of the hypotenuse.

---

### 4.12 — Area and Volume

```limn
are = lin joi lin | sph two dim
vol = lin joi lin joi lin | sph thr dim
cir are = rat cir lin joi lin
sph vol = rat sph lin joi lin joi lin
> area = line times line | surface two dimensions
> volume = line times line times line | sphere three dimensions
> circle area = ratio × circle line × line | ratio = pi
> sphere volume = ratio × sphere line × line × line | ratio = pi
```

**Context:** Area scales with length², volume with length³. Pi (π) relates circular/spherical measurements.

---

### 4.13 — Sequences and Convergence

```limn
seq = fra seq fra seq | srt
seq ris | seq fal | seq cyc | seq cha
seq lmt rea → seq sta | seq → val
seq lmt non rea → seq div | seq → non sta
if seq ris and seq lmt → seq mus sta
> sequence = fragment then fragment then | ordered
> sequence rising | sequence falling | sequence cycling | sequence changing
> sequence limit exists → sequence stabilizes | sequence → value
> sequence limit not existing → sequence diverges | sequence → not stable
> if sequence rising and sequence limited → sequence must stabilize
```

**Context:** Monotone bounded sequences converge. A sequence with a limit stabilizes; without one, it diverges.

---

### 4.14 — Logarithms

```limn
if two joi two joi two eql val → thr = how
how = rat joi | joi rep → val
rat big → val acc fas | rat sma → val gro slo
rat ris = rat joi add one → val joi two
> if 2 × 2 × 2 equals value → 3 = how many
> how-many = ratio of joins | joins repeated → value
> ratio big → value accelerates fast | ratio small → value grows slow
> ratio rise: adding one join → value times two
```

**Context:** Logarithms answer "how many times must I multiply?" Exponentials grow fast; logarithms grow slowly.

---

### 4.15 — Modular Arithmetic

```limn
cyc:val | aft val → beg | ris → beg bac
fiv add thr = two:cyc thr | ris → fal bac
eql:cyc | dif abs → sam:cyc
tau = cyc | aft dur → beg | now cyc alw
> cycle of value | after value → beginning | rise → beginning again
> five add three = two in cycle three | rises → falls back
> equal within cycle | different absolutely → same in cycle
> time = cycle | after duration → beginning | present cycles always
```

**Context:** Clock arithmetic: numbers wrap around. 5 + 3 = 2 (mod 3). Different numbers can be equivalent within cycles.

---

### 4.16 — Matrix Operations

```limn
dat rec srt | lin and lin
rec joi rec → rec new | rul def
rec tra = lin cha lin | map → map
rec joi rec ≠ rec joi rec bac | seq mea
> data rectangle ordered | lines and lines
> rectangle joins rectangle → new rectangle | rule defined
> rectangle transforms = lines change lines | maps → maps
> rectangle join rectangle ≠ rectangle join rectangle reversed | order matters
```

**Context:** Matrices: rectangular arrays of numbers. Multiplication is not commutative (AB ≠ BA in general). Matrices represent linear transformations.

---

### 4.17 — Optimization

```limn
val cha:inp | som inp → val max | som inp → val min
inp whe val cha zer → max or min
obs slo:val → inp nea max or min
slo ris → val dep min | slo fal → val hig max
> value changes with input | some input → value maximum | some input → value minimum
> input where value change zero → maximum or minimum
> observe slope of value → input near max or min
> slope rising → value at depth minimum | slope falling → value at height maximum
```

**Context:** Finding extrema: where the derivative equals zero. Rising slope approaches maximum from left; falling slope from right.

---

### 4.18 — Set Theory: Empty Set and Power Set

```limn
set emp = set non fra | rea | set all wit
set str = set all sub | set sma → set big
set emp wit set str alw | set ful wit set str alw
set fra → set str fra = two joi fra
> empty set = set without fragments | exists | within all sets
> power set = set of all subsets | set small → set big
> empty set within power set always | full set within power set always
> set fragments count → power set fragments = two to the power of fragment count
```

**Context:** The empty set belongs to every set. Power set contains all subsets. |P(S)| = 2^|S|.

---

### 4.19 — The Fundamental Theorem of Calculus

```limn
sum sma fra = tot | fra sma^0.9 → tot prc
slo def val:poi | sum slo → cha tot
sum and slo = inv | one und oth → oth und one
fra zer → sum = slo bac | slo = sum for
> sum of small fragments = total | fragments very small → total precise
> slope defines value at point | sum of slopes → total change
> summation and slope = inverse | one undoes other → other undoes one
> fragments approach zero → sum = slope reversed | slope = sum forward
```

**Context:** Integration and differentiation are inverse operations. The integral of a derivative recovers the original function.

---

### 4.20 — Boolean Logic

```limn
tru or fal | two val onl
tru and tru → tru | tru and fal → fal
tru or fal → tru | fal or fal → fal
not tru → fal | not fal → tru
all rul beg her | all rul joi → sys
> true or false | two values only
> true and true → true | true and false → false
> true or false → true | false or false → false
> not true → false | not false → true
> all rules begin here | all rules joined → system
```

**Context:** Boolean algebra: the foundation of digital logic. AND, OR, NOT. Everything computational reduces to these operations.

---

### 4.21 — Pigeonhole Principle

```limn
if fra mor set → som set fra two
non all set one fra:fra mor
sim tru | str tru | non exc
if poi thr lin two → som lin poi two
> if fragments more than sets → some set has two fragments
> not all sets one fragment when fragments more
> simple truth | strong truth | no exceptions
> if points three and lines two → some line has two points
```

**Context:** If n+1 items go into n containers, at least one container holds 2+. Simple yet surprisingly powerful in proofs.

---

### 4.22 — Rational and Irrational Numbers

```limn
rat = fra two eql one | rat two joi → rat
non rat rea | non fra two eql
non rat add rat → non rat | non rat bet any rat two
rat and non rat joi → all val ful | non gap
> rational = fraction of two integers equaling one | two rationals joined → rational
> irrational exists | no fraction of two integers equals it
> irrational add rational → irrational | irrational between any two rationals
> rational and irrational joined → all values full | no gap
```

**Context:** Rationals are ratios of integers. Irrationals (like √2, π) cannot be expressed as fractions. Together they fill the number line.

---

### 4.23 — Topology: Continuity

```limn
nea inp → nea out | non gap | non brk
poi nea → val nea | sma cha inp → sma cha out
brk = poi whe nea non → nea | gap
flo = non brk all | smo tra inp → out
> near inputs → near outputs | no gaps | no breaks
> points near → values near | small change input → small change output
> break = point where near not → near | gap
> continuous = no breaks anywhere | smooth transformation input → output
```

**Context:** Topological continuity: small input changes produce small output changes. No jumps, no tears.

---

### 4.24 — Equivalence Relations

```limn
rel sel → sel | alw tru | ref
rel one → two and rel two → one | sym
rel one → two and rel two → thr → rel one → thr | tra
ref and sym and tra → eql rel
eql rel → set div fra | eac fra eql wit
> relation self → self | always true | reflexive
> relation one → two and relation two → one | symmetric
> relation one → two and two → three → relation one → three | transitive
> reflexive and symmetric and transitive → equivalence relation
> equivalence relation → set divides to fragments | each fragment equal within
```

**Context:** Equivalence relations partition sets into classes where members are "equivalent." Requires reflexivity, symmetry, transitivity.

---

### 4.25 — The Infinite

```limn
add one → add one → add one | non end
inf ≠ big | inf = non end
set inf sub fra → set inf sta | non les
som inf big oth inf | inf div
poi bet poi two → poi bet alw | inf bet
> add one → add one → add one | no end
> infinite ≠ big | infinite = no ending
> infinite set minus fragment → infinite set stays | not less
> some infinities bigger than other infinities | infinite diverse
> point between two points → points between always | infinite between
```

**Context:** Infinity is not a large number — it's the property of having no end. Cantor showed infinities come in different sizes. Real numbers are "more infinite" than naturals.

---

*fin | fra fou | fra sig = tot*
*> finished | domains four | fragments summed = total*
