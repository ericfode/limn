#!/bin/bash
# Limn MCP Server - JSON-RPC wrapper for Prolog core
# =========================================================
# fab mcp | jso bri | prl cor
# *Building MCP. JSON bridge. Prolog core.*

set -euo pipefail

DIR="$(cd "$(dirname "$0")" && pwd)"
LINTER_DIR="$DIR/../linter"

# Ensure jq is available
command -v jq >/dev/null 2>&1 || { echo '{"jsonrpc":"2.0","error":{"code":-32603,"message":"jq required"}}'; exit 1; }

# Tool definitions for MCP
TOOLS='[
  {
    "name": "limn_interpret",
    "description": "Interpret a Limn sentence. Returns interpretations across domains, or collapsed if key provided.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "sentence": {"type": "string", "description": "The Limn sentence (e.g., sol liq tra)"},
        "key": {"type": "string", "description": "Optional context key to collapse ambiguity"}
      },
      "required": ["sentence"]
    }
  },
  {
    "name": "limn_compose",
    "description": "Create Limn sentences from English concepts.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "concept": {"type": "string", "description": "English concept to express in Limn"}
      },
      "required": ["concept"]
    }
  },
  {
    "name": "limn_validate",
    "description": "Check if Limn sentence contains valid vocabulary.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "sentence": {"type": "string", "description": "The Limn sentence to validate"}
      },
      "required": ["sentence"]
    }
  },
  {
    "name": "limn_teach",
    "description": "Get an interactive Limn teaching lesson.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "level": {"type": "integer", "description": "Lesson level 1-3", "default": 1}
      }
    }
  },
  {
    "name": "limn_poetry",
    "description": "Generate Limn poetry on a theme.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "theme": {"type": "string", "description": "Theme for poetry"}
      },
      "required": ["theme"]
    }
  },
  {
    "name": "limn_vocabulary",
    "description": "Look up Limn words or browse by domain.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "word": {"type": "string", "description": "Word to look up"},
        "domain": {"type": "string", "description": "Domain to browse"}
      }
    }
  }
]'

# Run Prolog query and capture output
run_prolog() {
    local goal="$1"
    cd "$DIR"
    scryer-prolog -g "consult('$LINTER_DIR/limn-vocab.pl'), consult('limn-mcp.pl'), $goal, halt" 2>/dev/null || echo "PROLOG_ERROR"
}

# Handle tool calls
handle_tool() {
    local tool="$1"
    local args="$2"

    case "$tool" in
        limn_validate)
            local sentence=$(echo "$args" | jq -r '.sentence // ""')
            local result=$(run_prolog "handle_validate('$sentence')")
            if echo "$result" | grep -q "PROLOG_ERROR"; then
                echo '{"content":[{"type":"text","text":"Error validating sentence"}]}'
            else
                local valid_count=$(echo "$result" | grep "VALID_COUNT:" | cut -d: -f2)
                local invalid=$(echo "$result" | grep "INVALID_WORDS:" | cut -d: -f2)
                if [ "$invalid" = "[]" ]; then
                    echo "{\"content\":[{\"type\":\"text\",\"text\":\"✓ Valid Limn. All $valid_count words recognized.\"}]}"
                else
                    echo "{\"content\":[{\"type\":\"text\",\"text\":\"⚠ Unknown words: $invalid\"}]}"
                fi
            fi
            ;;

        limn_interpret)
            local sentence=$(echo "$args" | jq -r '.sentence // ""')
            local key=$(echo "$args" | jq -r '.key // ""')
            # For interpret, we return a prompt for Claude to expand
            local prompt="Interpret this Limn sentence: \"$sentence\""
            if [ -n "$key" ]; then
                prompt="$prompt\nWith key: \"$key\""
            fi
            prompt="$prompt\n\nLimn words define REGIONS of meaning. Sentences combine by INTERSECTION. Generate 5 interpretations."
            echo "{\"content\":[{\"type\":\"text\",\"text\":$(echo "$prompt" | jq -Rs .)}]}"
            ;;

        limn_compose)
            local concept=$(echo "$args" | jq -r '.concept // ""')
            local prompt="Compose Limn for: \"$concept\"\n\nUse 3-letter Limn words. Domains: physical (sol,liq,gas,hot,col), mind (thi,fee,kno,dre), change (tra,mov,gro). Operators: nu (not), ve (very). Give 2-3 options."
            echo "{\"content\":[{\"type\":\"text\",\"text\":$(echo "$prompt" | jq -Rs .)}]}"
            ;;

        limn_teach)
            local level=$(echo "$args" | jq -r '.level // 1')
            case "$level" in
                1) echo '{"content":[{"type":"text","text":"## Lesson 1: Intersection\n\nIn Limn, words define REGIONS. `hot col` = thermal contrast, lukewarm, ambivalence.\n\n**Try:** What does `bri dim` mean?"}]}' ;;
                2) echo '{"content":[{"type":"text","text":"## Lesson 2: Order Independence\n\n`sol liq` = `liq sol` = ice, slush, phase boundary.\n\n**Try:** Rearrange `lif gro you` - all orderings mean the same!"}]}' ;;
                3) echo '{"content":[{"type":"text","text":"## Lesson 3: Operators\n\n`nu` negates the NEXT word only.\n`nu sol liq` = not-solid + liquid\n`sol nu liq` = solid + not-liquid\n\n**Try:** Compare `nu lif gro` vs `lif nu gro`"}]}' ;;
                *) echo '{"content":[{"type":"text","text":"Lessons 1-3 available."}]}' ;;
            esac
            ;;

        limn_poetry)
            local theme=$(echo "$args" | jq -r '.theme // "transformation"')
            local prompt="Write Limn poetry on: \"$theme\"\n\nUse 4-6 lines of valid Limn. Annotate each line with meaning.\n\nExample format:\n\`\`\`\nsol liq tra\nhot col cyc\n\`\`\`\nLine 1: solid→liquid→transform = ice melting\nLine 2: hot↔cold cycle = seasons"
            echo "{\"content\":[{\"type\":\"text\",\"text\":$(echo "$prompt" | jq -Rs .)}]}"
            ;;

        limn_vocabulary)
            local word=$(echo "$args" | jq -r '.word // ""')
            local domain=$(echo "$args" | jq -r '.domain // ""')
            if [ -n "$word" ]; then
                local result=$(run_prolog "handle_vocab_word('$word')")
                if echo "$result" | grep -q "FOUND:true"; then
                    echo "{\"content\":[{\"type\":\"text\",\"text\":\"✓ \`$word\` is valid Limn vocabulary.\"}]}"
                else
                    echo "{\"content\":[{\"type\":\"text\",\"text\":\"✗ \`$word\` not found in vocabulary.\"}]}"
                fi
            elif [ -n "$domain" ]; then
                echo "{\"content\":[{\"type\":\"text\",\"text\":\"Domain $domain: Run limn_validate on specific sentences.\"}]}"
            else
                echo '{"content":[{"type":"text","text":"Domains: physical, spatial, temporal, change, life, mind, communication, social, values.\nOperators: nu, ve, so, te, we, al, ex, on, yo, an, sa, mi, ma, eq"}]}'
            fi
            ;;

        *)
            echo "{\"error\":{\"code\":-32601,\"message\":\"Unknown tool: $tool\"}}"
            ;;
    esac
}

# Main JSON-RPC loop
while IFS= read -r line; do
    # Parse request
    method=$(echo "$line" | jq -r '.method // ""')
    id=$(echo "$line" | jq -r '.id // null')

    case "$method" in
        "initialize")
            # MCP initialization
            response='{
                "protocolVersion": "2024-11-05",
                "capabilities": {"tools": {}},
                "serverInfo": {"name": "limn-mcp", "version": "1.0.0"}
            }'
            echo "{\"jsonrpc\":\"2.0\",\"id\":$id,\"result\":$response}"
            ;;

        "tools/list")
            echo "{\"jsonrpc\":\"2.0\",\"id\":$id,\"result\":{\"tools\":$TOOLS}}"
            ;;

        "tools/call")
            tool=$(echo "$line" | jq -r '.params.name // ""')
            args=$(echo "$line" | jq -c '.params.arguments // {}')
            result=$(handle_tool "$tool" "$args")
            echo "{\"jsonrpc\":\"2.0\",\"id\":$id,\"result\":$result}"
            ;;

        "notifications/initialized")
            # No response needed for notifications
            ;;

        *)
            if [ -n "$method" ]; then
                echo "{\"jsonrpc\":\"2.0\",\"id\":$id,\"error\":{\"code\":-32601,\"message\":\"Method not found: $method\"}}"
            fi
            ;;
    esac
done
